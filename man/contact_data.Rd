% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/contact-analysis.r
\name{contact_data}
\alias{contact_data}
\title{Calculate Data for Contact Analysis}
\usage{
contact_data(df, grade, bhid = bhid, from = from, to = to, x = x,
  y = y, z = z, domain = domain, max_dist = 15, min_samp = 5)
}
\arguments{
\item{df}{Data frame with columns defined in the following arguments.}

\item{grade}{Name of column in \code{df} containing numeric values to be
averaged by contact distance.}

\item{bhid}{Name of column in \code{df} containing character or numeric
categorical hole ID (default `bhid`) identifying each unique drillhole.}

\item{from, to}{Name of numeric columns of \code{df} with the downhole
distance to the start and end of sample intervals (defaults \code{from} and
\code{to}).}

\item{x, y, z}{Name of numeric columns of \code{df} with the cartesian
coordinates of the sample mid-points (defaults \code{x}, \code{y}, and
\code{z}).}

\item{domain}{Name of the column in \code{df} containing the character or
numeric categorical codes for domains across which contact analysis will be
performed (default \code{domain}).}

\item{max_dist}{Positive numeric scalar for the maximum contact distance to
be calculated (default \code{15}).}

\item{min_samp}{Positive integer scalar for the minimum number of samples on
each side of the contact (default \code{5}). If less than this the data
won't be returned. This helps remove domain pairings with too few data.}
}
\value{
A list of two data frames 'detail' and 'summary'. 'detail' contains
  all data points while 'summary' contains mean grade by binned distances.
}
\description{
\code{contact_data} generates data from domain-coded drillhole data suitable
for plotting contact analysis plots. For each possible pairing of categorical
domain codes it reports the distance and grade of drillhole samples from each
contact of the domain pairing. The distance for the first domain in the
pairing ('left' side) is reported as a negative distance for plotting
purposes.
}
\details{
Uses nested for loops, which is not ideal for speed. I am sure that more can
be done by vecorizing one or more loops, but, for now, it works and is fast
enought to be practical. For example: the dataset 'dholes' contains 24,673
records in 371 drillholes with 13 valid domain contact pairings. This dataset
takes <50 seconds to process on a fast laptop (2018 i9 CPU).
}
\examples{
# Smaller dataset for speed.
dholes_sub <- dholes[dholes$domain < 4000,]
ca <- contact_data(dholes_sub, grade, max_dist = 20)

# Extract only certain contacts from contact data.
ca_1100 <- purrr::map(ca, ~dplyr::filter(.x, grepl("1100", contact)))
}
